//----------------------
// <auto-generated>
//     Generated using the NSwag toolchain v14.0.1.0 (NJsonSchema v11.0.0.0 (Newtonsoft.Json v13.0.0.0)) (http://NSwag.org)
// </auto-generated>
//----------------------

/* tslint:disable */
/* eslint-disable */
// ReSharper disable InconsistentNaming

import { mergeMap as _observableMergeMap, catchError as _observableCatch } from 'rxjs/operators';
import { Observable, throwError as _observableThrow, of as _observableOf } from 'rxjs';
import { Injectable, Inject, Optional, InjectionToken } from '@angular/core';
import { HttpClient, HttpHeaders, HttpResponse, HttpResponseBase } from '@angular/common/http';

export const MIXSERVER_BASE_URL = new InjectionToken<string>('MIXSERVER_BASE_URL');

export interface IDeviceClient {
    devices(): Observable<GetUsersDevicesQueryResponse>;
    deleteDevice(deviceId: string): Observable<void>;
    setDeviceInteracted(command: SetDeviceInteractionCommand): Observable<void>;
    updateDeviceCapabilities(command: UpdateDevicePlaybackCapabilitiesCommand): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class DeviceClient implements IDeviceClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MIXSERVER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    devices(): Observable<GetUsersDevicesQueryResponse> {
        let url_ = this.baseUrl + "/api/device";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDevices(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDevices(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUsersDevicesQueryResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUsersDevicesQueryResponse>;
        }));
    }

    protected processDevices(response: HttpResponseBase): Observable<GetUsersDevicesQueryResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUsersDevicesQueryResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteDevice(deviceId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/device/{deviceId}";
        if (deviceId === undefined || deviceId === null)
            throw new Error("The parameter 'deviceId' must be defined.");
        url_ = url_.replace("{deviceId}", encodeURIComponent("" + deviceId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteDevice(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteDevice(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteDevice(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setDeviceInteracted(command: SetDeviceInteractionCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/device/interacted";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetDeviceInteracted(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetDeviceInteracted(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetDeviceInteracted(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateDeviceCapabilities(command: UpdateDevicePlaybackCapabilitiesCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/device/capabilities";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateDeviceCapabilities(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateDeviceCapabilities(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateDeviceCapabilities(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface INodeClient {
    getNode(rootPath?: string | null | undefined, relativePath?: string | null | undefined): Observable<FileExplorerFolderResponse>;
    refreshFolder(command: RefreshFolderCommand): Observable<FileExplorerFolderResponse>;
    setFolderSortMode(command: SetFolderSortCommand): Observable<void>;
    getFolderScanStatus(): Observable<FolderScanStatusDto>;
}

@Injectable({
    providedIn: 'root'
})
export class NodeClient implements INodeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MIXSERVER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getNode(rootPath?: string | null | undefined, relativePath?: string | null | undefined): Observable<FileExplorerFolderResponse> {
        let url_ = this.baseUrl + "/api/node?";
        if (rootPath !== undefined && rootPath !== null)
            url_ += "RootPath=" + encodeURIComponent("" + rootPath) + "&";
        if (relativePath !== undefined && relativePath !== null)
            url_ += "RelativePath=" + encodeURIComponent("" + relativePath) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetNode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetNode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileExplorerFolderResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileExplorerFolderResponse>;
        }));
    }

    protected processGetNode(response: HttpResponseBase): Observable<FileExplorerFolderResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileExplorerFolderResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    refreshFolder(command: RefreshFolderCommand): Observable<FileExplorerFolderResponse> {
        let url_ = this.baseUrl + "/api/node/refresh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefreshFolder(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefreshFolder(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileExplorerFolderResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileExplorerFolderResponse>;
        }));
    }

    protected processRefreshFolder(response: HttpResponseBase): Observable<FileExplorerFolderResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FileExplorerFolderResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setFolderSortMode(command: SetFolderSortCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/node/sort";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetFolderSortMode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetFolderSortMode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetFolderSortMode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    getFolderScanStatus(): Observable<FolderScanStatusDto> {
        let url_ = this.baseUrl + "/api/node/scan";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetFolderScanStatus(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetFolderScanStatus(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FolderScanStatusDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FolderScanStatusDto>;
        }));
    }

    protected processGetFolderScanStatus(response: HttpResponseBase): Observable<FolderScanStatusDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = FolderScanStatusDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface INodeManagementClient {
    copyNode(command: CopyNodeCommand): Observable<void>;
    deleteNode(command: DeleteNodeCommand): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class NodeManagementClient implements INodeManagementClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MIXSERVER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    copyNode(command: CopyNodeCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/nodemanagement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processCopyNode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processCopyNode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processCopyNode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 409) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result409: any = null;
            let resultData409 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result409 = ProblemDetails.fromJS(resultData409);
            return throwException("A server side error occurred.", status, _responseText, _headers, result409);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteNode(command: DeleteNodeCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/nodemanagement";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteNode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteNode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteNode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IQueueClient {
    queue(): Observable<QueueSnapshotDto>;
    addToQueue(command: AddToQueueCommand): Observable<QueueSnapshotDto>;
    removeFromQueue(queueItemId: string): Observable<QueueSnapshotDto>;
    removeFromQueue2(command: RemoveFromQueueCommand): Observable<QueueSnapshotDto>;
    setQueuePosition(command: SetQueuePositionCommand): Observable<CurrentSessionUpdatedDto>;
}

@Injectable({
    providedIn: 'root'
})
export class QueueClient implements IQueueClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MIXSERVER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    queue(): Observable<QueueSnapshotDto> {
        let url_ = this.baseUrl + "/api/queue";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processQueue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processQueue(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QueueSnapshotDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QueueSnapshotDto>;
        }));
    }

    protected processQueue(response: HttpResponseBase): Observable<QueueSnapshotDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QueueSnapshotDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ValidationProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addToQueue(command: AddToQueueCommand): Observable<QueueSnapshotDto> {
        let url_ = this.baseUrl + "/api/queue";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddToQueue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddToQueue(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QueueSnapshotDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QueueSnapshotDto>;
        }));
    }

    protected processAddToQueue(response: HttpResponseBase): Observable<QueueSnapshotDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QueueSnapshotDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ValidationProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removeFromQueue(queueItemId: string): Observable<QueueSnapshotDto> {
        let url_ = this.baseUrl + "/api/queue/item/{queueItemId}";
        if (queueItemId === undefined || queueItemId === null)
            throw new Error("The parameter 'queueItemId' must be defined.");
        url_ = url_.replace("{queueItemId}", encodeURIComponent("" + queueItemId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveFromQueue(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveFromQueue(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QueueSnapshotDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QueueSnapshotDto>;
        }));
    }

    protected processRemoveFromQueue(response: HttpResponseBase): Observable<QueueSnapshotDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QueueSnapshotDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ValidationProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    removeFromQueue2(command: RemoveFromQueueCommand): Observable<QueueSnapshotDto> {
        let url_ = this.baseUrl + "/api/queue/item";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRemoveFromQueue2(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRemoveFromQueue2(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<QueueSnapshotDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<QueueSnapshotDto>;
        }));
    }

    protected processRemoveFromQueue2(response: HttpResponseBase): Observable<QueueSnapshotDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = QueueSnapshotDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ValidationProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setQueuePosition(command: SetQueuePositionCommand): Observable<CurrentSessionUpdatedDto> {
        let url_ = this.baseUrl + "/api/queue/position";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetQueuePosition(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetQueuePosition(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrentSessionUpdatedDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrentSessionUpdatedDto>;
        }));
    }

    protected processSetQueuePosition(response: HttpResponseBase): Observable<CurrentSessionUpdatedDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrentSessionUpdatedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ValidationProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ISessionClient {
    syncPlaybackSession(command: SyncPlaybackSessionCommand): Observable<SyncPlaybackSessionResponse>;
    setCurrentSession(command: SetCurrentSessionCommand): Observable<CurrentSessionUpdatedDto>;
    clearCurrentSession(): Observable<CurrentSessionUpdatedDto>;
    back(): Observable<CurrentSessionUpdatedDto>;
    skip(): Observable<CurrentSessionUpdatedDto>;
    end(): Observable<CurrentSessionUpdatedDto>;
    history(startIndex?: number | undefined, pageSize?: number | undefined): Observable<GetUsersSessionsResponse>;
    requestPlayback(command: RequestPlaybackCommand): Observable<PlaybackGrantedDto>;
    requestPause(): Observable<void>;
    setPlaying(command: SetPlayingCommand): Observable<void>;
    seek(command: SeekRequest): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class SessionClient implements ISessionClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MIXSERVER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    syncPlaybackSession(command: SyncPlaybackSessionCommand): Observable<SyncPlaybackSessionResponse> {
        let url_ = this.baseUrl + "/api/session/sync";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSyncPlaybackSession(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSyncPlaybackSession(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SyncPlaybackSessionResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SyncPlaybackSessionResponse>;
        }));
    }

    protected processSyncPlaybackSession(response: HttpResponseBase): Observable<SyncPlaybackSessionResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SyncPlaybackSessionResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setCurrentSession(command: SetCurrentSessionCommand): Observable<CurrentSessionUpdatedDto> {
        let url_ = this.baseUrl + "/api/session";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetCurrentSession(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetCurrentSession(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrentSessionUpdatedDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrentSessionUpdatedDto>;
        }));
    }

    protected processSetCurrentSession(response: HttpResponseBase): Observable<CurrentSessionUpdatedDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrentSessionUpdatedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    clearCurrentSession(): Observable<CurrentSessionUpdatedDto> {
        let url_ = this.baseUrl + "/api/session";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processClearCurrentSession(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processClearCurrentSession(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrentSessionUpdatedDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrentSessionUpdatedDto>;
        }));
    }

    protected processClearCurrentSession(response: HttpResponseBase): Observable<CurrentSessionUpdatedDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrentSessionUpdatedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    back(): Observable<CurrentSessionUpdatedDto> {
        let url_ = this.baseUrl + "/api/session/back";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processBack(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processBack(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrentSessionUpdatedDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrentSessionUpdatedDto>;
        }));
    }

    protected processBack(response: HttpResponseBase): Observable<CurrentSessionUpdatedDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrentSessionUpdatedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    skip(): Observable<CurrentSessionUpdatedDto> {
        let url_ = this.baseUrl + "/api/session/skip";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSkip(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSkip(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrentSessionUpdatedDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrentSessionUpdatedDto>;
        }));
    }

    protected processSkip(response: HttpResponseBase): Observable<CurrentSessionUpdatedDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrentSessionUpdatedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    end(): Observable<CurrentSessionUpdatedDto> {
        let url_ = this.baseUrl + "/api/session/end";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processEnd(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processEnd(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<CurrentSessionUpdatedDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<CurrentSessionUpdatedDto>;
        }));
    }

    protected processEnd(response: HttpResponseBase): Observable<CurrentSessionUpdatedDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = CurrentSessionUpdatedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    history(startIndex?: number | undefined, pageSize?: number | undefined): Observable<GetUsersSessionsResponse> {
        let url_ = this.baseUrl + "/api/session/history?";
        if (startIndex === null)
            throw new Error("The parameter 'startIndex' cannot be null.");
        else if (startIndex !== undefined)
            url_ += "StartIndex=" + encodeURIComponent("" + startIndex) + "&";
        if (pageSize === null)
            throw new Error("The parameter 'pageSize' cannot be null.");
        else if (pageSize !== undefined)
            url_ += "PageSize=" + encodeURIComponent("" + pageSize) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processHistory(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processHistory(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetUsersSessionsResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetUsersSessionsResponse>;
        }));
    }

    protected processHistory(response: HttpResponseBase): Observable<GetUsersSessionsResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetUsersSessionsResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    requestPlayback(command: RequestPlaybackCommand): Observable<PlaybackGrantedDto> {
        let url_ = this.baseUrl + "/api/session/request-playback";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestPlayback(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestPlayback(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<PlaybackGrantedDto>;
                }
            } else
                return _observableThrow(response_) as any as Observable<PlaybackGrantedDto>;
        }));
    }

    protected processRequestPlayback(response: HttpResponseBase): Observable<PlaybackGrantedDto> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = PlaybackGrantedDto.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ValidationProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    requestPause(): Observable<void> {
        let url_ = this.baseUrl + "/api/session/request-pause";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestPause(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestPause(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRequestPause(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ValidationProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    setPlaying(command: SetPlayingCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/session/playing";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSetPlaying(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSetPlaying(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSetPlaying(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ValidationProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    seek(command: SeekRequest): Observable<void> {
        let url_ = this.baseUrl + "/api/session/seek";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSeek(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSeek(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processSeek(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ValidationProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IStreamClient {
    getStream(id: string, key?: string | undefined, expires?: number | undefined, deviceId?: string | undefined): Observable<FileResponse | null>;
}

@Injectable({
    providedIn: 'root'
})
export class StreamClient implements IStreamClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MIXSERVER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getStream(id: string, key?: string | undefined, expires?: number | undefined, deviceId?: string | undefined): Observable<FileResponse | null> {
        let url_ = this.baseUrl + "/api/stream/{id}?";
        if (id === undefined || id === null)
            throw new Error("The parameter 'id' must be defined.");
        url_ = url_.replace("{id}", encodeURIComponent("" + id));
        if (key === null)
            throw new Error("The parameter 'key' cannot be null.");
        else if (key !== undefined)
            url_ += "Key=" + encodeURIComponent("" + key) + "&";
        if (expires === null)
            throw new Error("The parameter 'expires' cannot be null.");
        else if (expires !== undefined)
            url_ += "Expires=" + encodeURIComponent("" + expires) + "&";
        if (deviceId === null)
            throw new Error("The parameter 'deviceId' cannot be null.");
        else if (deviceId !== undefined)
            url_ += "DeviceId=" + encodeURIComponent("" + deviceId) + "&";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/octet-stream"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetStream(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetStream(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<FileResponse | null>;
                }
            } else
                return _observableThrow(response_) as any as Observable<FileResponse | null>;
        }));
    }

    protected processGetStream(response: HttpResponseBase): Observable<FileResponse | null> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200 || status === 206) {
            const contentDisposition = response.headers ? response.headers.get("content-disposition") : undefined;
            let fileNameMatch = contentDisposition ? /filename\*=(?:(\\?['"])(.*?)\1|(?:[^\s]+'.*?')?([^;\n]*))/g.exec(contentDisposition) : undefined;
            let fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[3] || fileNameMatch[2] : undefined;
            if (fileName) {
                fileName = decodeURIComponent(fileName);
            } else {
                fileNameMatch = contentDisposition ? /filename="?([^"]*?)"?(;|$)/g.exec(contentDisposition) : undefined;
                fileName = fileNameMatch && fileNameMatch.length > 1 ? fileNameMatch[1] : undefined;
            }
            return _observableOf({ fileName: fileName, data: responseBlob as any, status: status, headers: _headers });
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITracklistClient {
    saveTracklist(command: SaveTracklistCommand): Observable<SaveTracklistResponse>;
    importTracklist(file?: FileParameter | undefined): Observable<ImportTracklistResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class TracklistClient implements ITracklistClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MIXSERVER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    saveTracklist(command: SaveTracklistCommand): Observable<SaveTracklistResponse> {
        let url_ = this.baseUrl + "/api/tracklist";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processSaveTracklist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processSaveTracklist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<SaveTracklistResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<SaveTracklistResponse>;
        }));
    }

    protected processSaveTracklist(response: HttpResponseBase): Observable<SaveTracklistResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = SaveTracklistResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    importTracklist(file?: FileParameter | undefined): Observable<ImportTracklistResponse> {
        let url_ = this.baseUrl + "/api/tracklist/import";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = new FormData();
        if (file === null || file === undefined)
            throw new Error("The parameter 'file' cannot be null.");
        else
            content_.append("File", file.data, file.fileName ? file.fileName : "File");

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processImportTracklist(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processImportTracklist(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<ImportTracklistResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<ImportTracklistResponse>;
        }));
    }

    protected processImportTracklist(response: HttpResponseBase): Observable<ImportTracklistResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = ImportTracklistResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface ITranscodeClient {
    requestTranscode(command: RequestTranscodeCommand): Observable<void>;
}

@Injectable({
    providedIn: 'root'
})
export class TranscodeClient implements ITranscodeClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MIXSERVER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    requestTranscode(command: RequestTranscodeCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/transcode";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRequestTranscode(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRequestTranscode(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processRequestTranscode(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 202) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 404) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result404: any = null;
            let resultData404 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result404 = ProblemDetails.fromJS(resultData404);
            return throwException("A server side error occurred.", status, _responseText, _headers, result404);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export interface IUserClient {
    getAll(): Observable<GetAllUsersResponse>;
    addUser(command: AddUserCommand): Observable<AddUserCommandResponse>;
    updateUser(userId: string, command: UpdateUserCommand): Observable<void>;
    deleteUser(userId: string): Observable<void>;
    login(command: LoginUserCommand): Observable<LoginCommandResponse>;
    resetPassword(command: ResetPasswordCommand): Observable<void>;
    refresh(command: RefreshUserCommand): Observable<RefreshUserResponse>;
}

@Injectable({
    providedIn: 'root'
})
export class UserClient implements IUserClient {
    private http: HttpClient;
    private baseUrl: string;
    protected jsonParseReviver: ((key: string, value: any) => any) | undefined = undefined;

    constructor(@Inject(HttpClient) http: HttpClient, @Optional() @Inject(MIXSERVER_BASE_URL) baseUrl?: string) {
        this.http = http;
        this.baseUrl = baseUrl ?? "";
    }

    getAll(): Observable<GetAllUsersResponse> {
        let url_ = this.baseUrl + "/api/user";
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Accept": "application/json"
            })
        };

        return this.http.request("get", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processGetAll(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processGetAll(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<GetAllUsersResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<GetAllUsersResponse>;
        }));
    }

    protected processGetAll(response: HttpResponseBase): Observable<GetAllUsersResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = GetAllUsersResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    addUser(command: AddUserCommand): Observable<AddUserCommandResponse> {
        let url_ = this.baseUrl + "/api/user";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processAddUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processAddUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<AddUserCommandResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<AddUserCommandResponse>;
        }));
    }

    protected processAddUser(response: HttpResponseBase): Observable<AddUserCommandResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = AddUserCommandResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    updateUser(userId: string, command: UpdateUserCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/user/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("put", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processUpdateUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processUpdateUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processUpdateUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ValidationProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    deleteUser(userId: string): Observable<void> {
        let url_ = this.baseUrl + "/api/user/{userId}";
        if (userId === undefined || userId === null)
            throw new Error("The parameter 'userId' must be defined.");
        url_ = url_.replace("{userId}", encodeURIComponent("" + userId));
        url_ = url_.replace(/[?&]$/, "");

        let options_ : any = {
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
            })
        };

        return this.http.request("delete", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processDeleteUser(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processDeleteUser(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processDeleteUser(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ValidationProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    login(command: LoginUserCommand): Observable<LoginCommandResponse> {
        let url_ = this.baseUrl + "/api/user/login";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processLogin(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processLogin(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<LoginCommandResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<LoginCommandResponse>;
        }));
    }

    protected processLogin(response: HttpResponseBase): Observable<LoginCommandResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = LoginCommandResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    resetPassword(command: ResetPasswordCommand): Observable<void> {
        let url_ = this.baseUrl + "/api/user/reset";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processResetPassword(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processResetPassword(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<void>;
                }
            } else
                return _observableThrow(response_) as any as Observable<void>;
        }));
    }

    protected processResetPassword(response: HttpResponseBase): Observable<void> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return _observableOf(null as any);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 403) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result403: any = null;
            let resultData403 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result403 = ProblemDetails.fromJS(resultData403);
            return throwException("A server side error occurred.", status, _responseText, _headers, result403);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }

    refresh(command: RefreshUserCommand): Observable<RefreshUserResponse> {
        let url_ = this.baseUrl + "/api/user/refresh";
        url_ = url_.replace(/[?&]$/, "");

        const content_ = JSON.stringify(command);

        let options_ : any = {
            body: content_,
            observe: "response",
            responseType: "blob",
            headers: new HttpHeaders({
                "Content-Type": "application/json",
                "Accept": "application/json"
            })
        };

        return this.http.request("post", url_, options_).pipe(_observableMergeMap((response_ : any) => {
            return this.processRefresh(response_);
        })).pipe(_observableCatch((response_: any) => {
            if (response_ instanceof HttpResponseBase) {
                try {
                    return this.processRefresh(response_ as any);
                } catch (e) {
                    return _observableThrow(e) as any as Observable<RefreshUserResponse>;
                }
            } else
                return _observableThrow(response_) as any as Observable<RefreshUserResponse>;
        }));
    }

    protected processRefresh(response: HttpResponseBase): Observable<RefreshUserResponse> {
        const status = response.status;
        const responseBlob =
            response instanceof HttpResponse ? response.body :
            (response as any).error instanceof Blob ? (response as any).error : undefined;

        let _headers: any = {}; if (response.headers) { for (let key of response.headers.keys()) { _headers[key] = response.headers.get(key); }}
        if (status === 200) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result200: any = null;
            let resultData200 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result200 = RefreshUserResponse.fromJS(resultData200);
            return _observableOf(result200);
            }));
        } else if (status === 401) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result401: any = null;
            let resultData401 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result401 = ProblemDetails.fromJS(resultData401);
            return throwException("A server side error occurred.", status, _responseText, _headers, result401);
            }));
        } else if (status === 400) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            let result400: any = null;
            let resultData400 = _responseText === "" ? null : JSON.parse(_responseText, this.jsonParseReviver);
            result400 = ValidationProblemDetails.fromJS(resultData400);
            return throwException("A server side error occurred.", status, _responseText, _headers, result400);
            }));
        } else if (status !== 200 && status !== 204) {
            return blobToText(responseBlob).pipe(_observableMergeMap((_responseText: string) => {
            return throwException("An unexpected server error occurred.", status, _responseText, _headers);
            }));
        }
        return _observableOf(null as any);
    }
}

export class GetUsersDevicesQueryResponse implements IGetUsersDevicesQueryResponse {
    devices!: DeviceDto[];

    constructor(data?: IGetUsersDevicesQueryResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.devices = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["devices"])) {
                this.devices = [] as any;
                for (let item of _data["devices"])
                    this.devices!.push(DeviceDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUsersDevicesQueryResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetUsersDevicesQueryResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.devices)) {
            data["devices"] = [];
            for (let item of this.devices)
                data["devices"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetUsersDevicesQueryResponse {
    devices: DeviceDto[];
}

export class DeviceDto implements IDeviceDto {
    id!: string;
    lastSeen!: Date;
    clientType!: ClientType;
    deviceType!: DeviceType;
    interactedWith!: boolean;
    capabilities!: { [key: string]: boolean; };
    online!: boolean;
    browserName?: string | undefined;
    model?: string | undefined;
    brand?: string | undefined;
    osName?: string | undefined;
    osVersion?: string | undefined;

    constructor(data?: IDeviceDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.capabilities = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.lastSeen = _data["lastSeen"] ? new Date(_data["lastSeen"].toString()) : <any>undefined;
            this.clientType = _data["clientType"];
            this.deviceType = _data["deviceType"];
            this.interactedWith = _data["interactedWith"];
            if (_data["capabilities"]) {
                this.capabilities = {} as any;
                for (let key in _data["capabilities"]) {
                    if (_data["capabilities"].hasOwnProperty(key))
                        (<any>this.capabilities)![key] = _data["capabilities"][key];
                }
            }
            this.online = _data["online"];
            this.browserName = _data["browserName"];
            this.model = _data["model"];
            this.brand = _data["brand"];
            this.osName = _data["osName"];
            this.osVersion = _data["osVersion"];
        }
    }

    static fromJS(data: any): DeviceDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["lastSeen"] = this.lastSeen ? this.lastSeen.toISOString() : <any>undefined;
        data["clientType"] = this.clientType;
        data["deviceType"] = this.deviceType;
        data["interactedWith"] = this.interactedWith;
        if (this.capabilities) {
            data["capabilities"] = {};
            for (let key in this.capabilities) {
                if (this.capabilities.hasOwnProperty(key))
                    (<any>data["capabilities"])[key] = (<any>this.capabilities)[key];
            }
        }
        data["online"] = this.online;
        data["browserName"] = this.browserName;
        data["model"] = this.model;
        data["brand"] = this.brand;
        data["osName"] = this.osName;
        data["osVersion"] = this.osVersion;
        return data;
    }
}

export interface IDeviceDto {
    id: string;
    lastSeen: Date;
    clientType: ClientType;
    deviceType: DeviceType;
    interactedWith: boolean;
    capabilities: { [key: string]: boolean; };
    online: boolean;
    browserName?: string | undefined;
    model?: string | undefined;
    brand?: string | undefined;
    osName?: string | undefined;
    osVersion?: string | undefined;
}

export enum ClientType {
    Unknown = "Unknown",
    Browser = "Browser",
    FeedReader = "FeedReader",
    MediaPlayer = "MediaPlayer",
    MobileApp = "MobileApp",
    Library = "Library",
    Pim = "Pim",
}

export enum DeviceType {
    Desktop = "Desktop",
    Smartphone = "Smartphone",
    Tablet = "Tablet",
    FeaturePhone = "FeaturePhone",
    Console = "Console",
    Tv = "Tv",
    CarBrowser = "CarBrowser",
    SmartDisplay = "SmartDisplay",
    Camera = "Camera",
    PortableMediaPlayer = "PortableMediaPlayer",
    Phablet = "Phablet",
    SmartSpeaker = "SmartSpeaker",
    Wearable = "Wearable",
    Peripheral = "Peripheral",
    Unknown = "Unknown",
}

export class ProblemDetails implements IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions!: { [key: string]: any; };

    [key: string]: any;

    constructor(data?: IProblemDetails) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.extensions = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            this.type = _data["type"];
            this.title = _data["title"];
            this.status = _data["status"];
            this.detail = _data["detail"];
            this.instance = _data["instance"];
            if (_data["extensions"]) {
                this.extensions = {} as any;
                for (let key in _data["extensions"]) {
                    if (_data["extensions"].hasOwnProperty(key))
                        (<any>this.extensions)![key] = _data["extensions"][key];
                }
            }
        }
    }

    static fromJS(data: any): ProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ProblemDetails();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        data["type"] = this.type;
        data["title"] = this.title;
        data["status"] = this.status;
        data["detail"] = this.detail;
        data["instance"] = this.instance;
        if (this.extensions) {
            data["extensions"] = {};
            for (let key in this.extensions) {
                if (this.extensions.hasOwnProperty(key))
                    (<any>data["extensions"])[key] = (<any>this.extensions)[key];
            }
        }
        return data;
    }
}

export interface IProblemDetails {
    type?: string | undefined;
    title?: string | undefined;
    status?: number | undefined;
    detail?: string | undefined;
    instance?: string | undefined;
    extensions: { [key: string]: any; };

    [key: string]: any;
}

export class SetDeviceInteractionCommand implements ISetDeviceInteractionCommand {
    interacted!: boolean;

    constructor(data?: ISetDeviceInteractionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.interacted = _data["interacted"];
        }
    }

    static fromJS(data: any): SetDeviceInteractionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SetDeviceInteractionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["interacted"] = this.interacted;
        return data;
    }
}

export interface ISetDeviceInteractionCommand {
    interacted: boolean;
}

export class UpdateDevicePlaybackCapabilitiesCommand implements IUpdateDevicePlaybackCapabilitiesCommand {
    capabilities!: { [key: string]: boolean; };

    constructor(data?: IUpdateDevicePlaybackCapabilitiesCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.capabilities = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            if (_data["capabilities"]) {
                this.capabilities = {} as any;
                for (let key in _data["capabilities"]) {
                    if (_data["capabilities"].hasOwnProperty(key))
                        (<any>this.capabilities)![key] = _data["capabilities"][key];
                }
            }
        }
    }

    static fromJS(data: any): UpdateDevicePlaybackCapabilitiesCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateDevicePlaybackCapabilitiesCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (this.capabilities) {
            data["capabilities"] = {};
            for (let key in this.capabilities) {
                if (this.capabilities.hasOwnProperty(key))
                    (<any>data["capabilities"])[key] = (<any>this.capabilities)[key];
            }
        }
        return data;
    }
}

export interface IUpdateDevicePlaybackCapabilitiesCommand {
    capabilities: { [key: string]: boolean; };
}

export class FileExplorerFolderResponse implements IFileExplorerFolderResponse {
    node!: FileExplorerFolderNodeResponse;
    children!: FileExplorerNodeResponse[];
    sort!: FolderSortDto;

    protected _discriminator: string;

    constructor(data?: IFileExplorerFolderResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.node = new FileExplorerFolderNodeResponse();
            this.children = [];
            this.sort = new FolderSortDto();
        }
        this._discriminator = "FileExplorerFolderResponse";
    }

    init(_data?: any) {
        if (_data) {
            this.node = _data["node"] ? FileExplorerFolderNodeResponse.fromJS(_data["node"]) : new FileExplorerFolderNodeResponse();
            if (Array.isArray(_data["children"])) {
                this.children = [] as any;
                for (let item of _data["children"])
                    this.children!.push(FileExplorerNodeResponse.fromJS(item));
            }
            this.sort = _data["sort"] ? FolderSortDto.fromJS(_data["sort"]) : new FolderSortDto();
        }
    }

    static fromJS(data: any): FileExplorerFolderResponse {
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "RootFileExplorerFolderResponse") {
            let result = new RootFileExplorerFolderResponse();
            result.init(data);
            return result;
        }
        let result = new FileExplorerFolderResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discriminator"] = this._discriminator;
        data["node"] = this.node ? this.node.toJSON() : <any>undefined;
        if (Array.isArray(this.children)) {
            data["children"] = [];
            for (let item of this.children)
                data["children"].push(item.toJSON());
        }
        data["sort"] = this.sort ? this.sort.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFileExplorerFolderResponse {
    node: FileExplorerFolderNodeResponse;
    children: FileExplorerNodeResponse[];
    sort: FolderSortDto;
}

export class FileExplorerNodeResponse implements IFileExplorerNodeResponse {
    path!: NodePathDto;
    type!: FileExplorerNodeType;
    exists!: boolean;
    creationTimeUtc!: Date;

    protected _discriminator: string;

    constructor(data?: IFileExplorerNodeResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.path = new NodePathDto();
        }
        this._discriminator = "FileExplorerNodeResponse";
    }

    init(_data?: any) {
        if (_data) {
            this.path = _data["path"] ? NodePathDto.fromJS(_data["path"]) : new NodePathDto();
            this.type = _data["type"];
            this.exists = _data["exists"];
            this.creationTimeUtc = _data["creationTimeUtc"] ? new Date(_data["creationTimeUtc"].toString()) : <any>undefined;
        }
    }

    static fromJS(data: any): FileExplorerNodeResponse {
        data = typeof data === 'object' ? data : {};
        if (data["discriminator"] === "FileExplorerFolderNodeResponse") {
            let result = new FileExplorerFolderNodeResponse();
            result.init(data);
            return result;
        }
        if (data["discriminator"] === "FileExplorerFileNodeResponse") {
            let result = new FileExplorerFileNodeResponse();
            result.init(data);
            return result;
        }
        let result = new FileExplorerNodeResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["discriminator"] = this._discriminator;
        data["path"] = this.path ? this.path.toJSON() : <any>undefined;
        data["type"] = this.type;
        data["exists"] = this.exists;
        data["creationTimeUtc"] = this.creationTimeUtc ? this.creationTimeUtc.toISOString() : <any>undefined;
        return data;
    }
}

export interface IFileExplorerNodeResponse {
    path: NodePathDto;
    type: FileExplorerNodeType;
    exists: boolean;
    creationTimeUtc: Date;
}

export class FileExplorerFolderNodeResponse extends FileExplorerNodeResponse implements IFileExplorerFolderNodeResponse {
    belongsToRoot!: boolean;
    belongsToRootChild!: boolean;
    parent?: FileExplorerFolderNodeResponse | undefined;

    constructor(data?: IFileExplorerFolderNodeResponse) {
        super(data);
        this._discriminator = "FileExplorerFolderNodeResponse";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.belongsToRoot = _data["belongsToRoot"];
            this.belongsToRootChild = _data["belongsToRootChild"];
            this.parent = _data["parent"] ? FileExplorerFolderNodeResponse.fromJS(_data["parent"]) : <any>undefined;
        }
    }

    static override fromJS(data: any): FileExplorerFolderNodeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new FileExplorerFolderNodeResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["belongsToRoot"] = this.belongsToRoot;
        data["belongsToRootChild"] = this.belongsToRootChild;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IFileExplorerFolderNodeResponse extends IFileExplorerNodeResponse {
    belongsToRoot: boolean;
    belongsToRootChild: boolean;
    parent?: FileExplorerFolderNodeResponse | undefined;
}

export class NodePathRequestDto implements INodePathRequestDto {
    rootPath?: string | undefined;
    relativePath?: string | undefined;

    constructor(data?: INodePathRequestDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.rootPath = _data["rootPath"];
            this.relativePath = _data["relativePath"];
        }
    }

    static fromJS(data: any): NodePathRequestDto {
        data = typeof data === 'object' ? data : {};
        let result = new NodePathRequestDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["rootPath"] = this.rootPath;
        data["relativePath"] = this.relativePath;
        return data;
    }
}

export interface INodePathRequestDto {
    rootPath?: string | undefined;
    relativePath?: string | undefined;
}

export class NodePathDto extends NodePathRequestDto implements INodePathDto {
    fileName!: string;
    absolutePath!: string;
    extension!: string;
    parent!: NodePathHeaderDto;
    isRoot!: boolean;
    isRootChild!: boolean;

    constructor(data?: INodePathDto) {
        super(data);
        if (!data) {
            this.parent = new NodePathHeaderDto();
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.fileName = _data["fileName"];
            this.absolutePath = _data["absolutePath"];
            this.extension = _data["extension"];
            this.parent = _data["parent"] ? NodePathHeaderDto.fromJS(_data["parent"]) : new NodePathHeaderDto();
            this.isRoot = _data["isRoot"];
            this.isRootChild = _data["isRootChild"];
        }
    }

    static override fromJS(data: any): NodePathDto {
        data = typeof data === 'object' ? data : {};
        let result = new NodePathDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["fileName"] = this.fileName;
        data["absolutePath"] = this.absolutePath;
        data["extension"] = this.extension;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["isRoot"] = this.isRoot;
        data["isRootChild"] = this.isRootChild;
        super.toJSON(data);
        return data;
    }
}

export interface INodePathDto extends INodePathRequestDto {
    fileName: string;
    absolutePath: string;
    extension: string;
    parent: NodePathHeaderDto;
    isRoot: boolean;
    isRootChild: boolean;
}

export class NodePathHeaderDto extends NodePathRequestDto implements INodePathHeaderDto {
    absolutePath!: string;

    constructor(data?: INodePathHeaderDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.absolutePath = _data["absolutePath"];
        }
    }

    static override fromJS(data: any): NodePathHeaderDto {
        data = typeof data === 'object' ? data : {};
        let result = new NodePathHeaderDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["absolutePath"] = this.absolutePath;
        super.toJSON(data);
        return data;
    }
}

export interface INodePathHeaderDto extends INodePathRequestDto {
    absolutePath: string;
}

export enum FileExplorerNodeType {
    File = "File",
    Folder = "Folder",
}

export class FileExplorerFileNodeResponse extends FileExplorerNodeResponse implements IFileExplorerFileNodeResponse {
    metadata!: FileMetadataResponse;
    playbackSupported!: boolean;
    parent!: FileExplorerFolderNodeResponse;

    constructor(data?: IFileExplorerFileNodeResponse) {
        super(data);
        if (!data) {
            this.metadata = new FileMetadataResponse();
            this.parent = new FileExplorerFolderNodeResponse();
        }
        this._discriminator = "FileExplorerFileNodeResponse";
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.metadata = _data["metadata"] ? FileMetadataResponse.fromJS(_data["metadata"]) : new FileMetadataResponse();
            this.playbackSupported = _data["playbackSupported"];
            this.parent = _data["parent"] ? FileExplorerFolderNodeResponse.fromJS(_data["parent"]) : new FileExplorerFolderNodeResponse();
        }
    }

    static override fromJS(data: any): FileExplorerFileNodeResponse {
        data = typeof data === 'object' ? data : {};
        let result = new FileExplorerFileNodeResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["metadata"] = this.metadata ? this.metadata.toJSON() : <any>undefined;
        data["playbackSupported"] = this.playbackSupported;
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        super.toJSON(data);
        return data;
    }
}

export interface IFileExplorerFileNodeResponse extends IFileExplorerNodeResponse {
    metadata: FileMetadataResponse;
    playbackSupported: boolean;
    parent: FileExplorerFolderNodeResponse;
}

export class FileMetadataResponse implements IFileMetadataResponse {
    mimeType!: string;
    isMedia!: boolean;
    mediaInfo?: MediaInfoDto | undefined;
    transcodeStatus!: TranscodeState;

    constructor(data?: IFileMetadataResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.mimeType = _data["mimeType"];
            this.isMedia = _data["isMedia"];
            this.mediaInfo = _data["mediaInfo"] ? MediaInfoDto.fromJS(_data["mediaInfo"]) : <any>undefined;
            this.transcodeStatus = _data["transcodeStatus"];
        }
    }

    static fromJS(data: any): FileMetadataResponse {
        data = typeof data === 'object' ? data : {};
        let result = new FileMetadataResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["mimeType"] = this.mimeType;
        data["isMedia"] = this.isMedia;
        data["mediaInfo"] = this.mediaInfo ? this.mediaInfo.toJSON() : <any>undefined;
        data["transcodeStatus"] = this.transcodeStatus;
        return data;
    }
}

export interface IFileMetadataResponse {
    mimeType: string;
    isMedia: boolean;
    mediaInfo?: MediaInfoDto | undefined;
    transcodeStatus: TranscodeState;
}

export class MediaInfoDto implements IMediaInfoDto {
    nodePath!: NodePathDto;
    bitrate!: number;
    duration!: string;

    constructor(data?: IMediaInfoDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.nodePath = new NodePathDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nodePath = _data["nodePath"] ? NodePathDto.fromJS(_data["nodePath"]) : new NodePathDto();
            this.bitrate = _data["bitrate"];
            this.duration = _data["duration"];
        }
    }

    static fromJS(data: any): MediaInfoDto {
        data = typeof data === 'object' ? data : {};
        let result = new MediaInfoDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nodePath"] = this.nodePath ? this.nodePath.toJSON() : <any>undefined;
        data["bitrate"] = this.bitrate;
        data["duration"] = this.duration;
        return data;
    }
}

export interface IMediaInfoDto {
    nodePath: NodePathDto;
    bitrate: number;
    duration: string;
}

export enum TranscodeState {
    None = "None",
    InProgress = "InProgress",
    Completed = "Completed",
}

export class FolderSortDto implements IFolderSortDto {
    descending!: boolean;
    sortMode!: FolderSortMode;

    constructor(data?: IFolderSortDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.descending = _data["descending"];
            this.sortMode = _data["sortMode"];
        }
    }

    static fromJS(data: any): FolderSortDto {
        data = typeof data === 'object' ? data : {};
        let result = new FolderSortDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["descending"] = this.descending;
        data["sortMode"] = this.sortMode;
        return data;
    }
}

export interface IFolderSortDto {
    descending: boolean;
    sortMode: FolderSortMode;
}

export enum FolderSortMode {
    Name = "Name",
    Created = "Created",
}

export class RootFileExplorerFolderResponse extends FileExplorerFolderResponse implements IRootFileExplorerFolderResponse {

    constructor(data?: IRootFileExplorerFolderResponse) {
        super(data);
        this._discriminator = "RootFileExplorerFolderResponse";
    }

    override init(_data?: any) {
        super.init(_data);
    }

    static override fromJS(data: any): RootFileExplorerFolderResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RootFileExplorerFolderResponse();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        super.toJSON(data);
        return data;
    }
}

export interface IRootFileExplorerFolderResponse extends IFileExplorerFolderResponse {
}

export class HttpValidationProblemDetails extends ProblemDetails implements IHttpValidationProblemDetails {
    errors!: { [key: string]: string[]; };

    [key: string]: any;

    constructor(data?: IHttpValidationProblemDetails) {
        super(data);
        if (!data) {
            this.errors = {};
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static override fromJS(data: any): HttpValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new HttpValidationProblemDetails();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = (<any>this.errors)[key];
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface IHttpValidationProblemDetails extends IProblemDetails {
    errors: { [key: string]: string[]; };

    [key: string]: any;
}

export class ValidationProblemDetails extends HttpValidationProblemDetails implements IValidationProblemDetails {
    override errors!: { [key: string]: string[]; };

    [key: string]: any;

    constructor(data?: IValidationProblemDetails) {
        super(data);
        if (!data) {
            this.errors = {};
        }
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            for (var property in _data) {
                if (_data.hasOwnProperty(property))
                    this[property] = _data[property];
            }
            if (_data["errors"]) {
                this.errors = {} as any;
                for (let key in _data["errors"]) {
                    if (_data["errors"].hasOwnProperty(key))
                        (<any>this.errors)![key] = _data["errors"][key] !== undefined ? _data["errors"][key] : [];
                }
            }
        }
    }

    static override fromJS(data: any): ValidationProblemDetails {
        data = typeof data === 'object' ? data : {};
        let result = new ValidationProblemDetails();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        for (var property in this) {
            if (this.hasOwnProperty(property))
                data[property] = this[property];
        }
        if (this.errors) {
            data["errors"] = {};
            for (let key in this.errors) {
                if (this.errors.hasOwnProperty(key))
                    (<any>data["errors"])[key] = (<any>this.errors)[key];
            }
        }
        super.toJSON(data);
        return data;
    }
}

export interface IValidationProblemDetails extends IHttpValidationProblemDetails {
    errors: { [key: string]: string[]; };

    [key: string]: any;
}

export class RefreshFolderCommand implements IRefreshFolderCommand {
    nodePath?: NodePathRequestDto | undefined;

    constructor(data?: IRefreshFolderCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nodePath = _data["nodePath"] ? NodePathRequestDto.fromJS(_data["nodePath"]) : <any>undefined;
        }
    }

    static fromJS(data: any): RefreshFolderCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshFolderCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nodePath"] = this.nodePath ? this.nodePath.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRefreshFolderCommand {
    nodePath?: NodePathRequestDto | undefined;
}

export class SetFolderSortCommand implements ISetFolderSortCommand {
    nodePath!: NodePathRequestDto;
    descending!: boolean;
    sortMode!: FolderSortMode;

    constructor(data?: ISetFolderSortCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.nodePath = new NodePathRequestDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nodePath = _data["nodePath"] ? NodePathRequestDto.fromJS(_data["nodePath"]) : new NodePathRequestDto();
            this.descending = _data["descending"];
            this.sortMode = _data["sortMode"];
        }
    }

    static fromJS(data: any): SetFolderSortCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SetFolderSortCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nodePath"] = this.nodePath ? this.nodePath.toJSON() : <any>undefined;
        data["descending"] = this.descending;
        data["sortMode"] = this.sortMode;
        return data;
    }
}

export interface ISetFolderSortCommand {
    nodePath: NodePathRequestDto;
    descending: boolean;
    sortMode: FolderSortMode;
}

export class FolderScanStatusDto implements IFolderScanStatusDto {
    scanInProgress!: boolean;

    constructor(data?: IFolderScanStatusDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.scanInProgress = _data["scanInProgress"];
        }
    }

    static fromJS(data: any): FolderScanStatusDto {
        data = typeof data === 'object' ? data : {};
        let result = new FolderScanStatusDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["scanInProgress"] = this.scanInProgress;
        return data;
    }
}

export interface IFolderScanStatusDto {
    scanInProgress: boolean;
}

export class CopyNodeCommand implements ICopyNodeCommand {
    sourcePath!: NodePathRequestDto;
    destinationPath!: NodePathRequestDto;
    move!: boolean;
    overwrite!: boolean;

    constructor(data?: ICopyNodeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.sourcePath = new NodePathRequestDto();
            this.destinationPath = new NodePathRequestDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.sourcePath = _data["sourcePath"] ? NodePathRequestDto.fromJS(_data["sourcePath"]) : new NodePathRequestDto();
            this.destinationPath = _data["destinationPath"] ? NodePathRequestDto.fromJS(_data["destinationPath"]) : new NodePathRequestDto();
            this.move = _data["move"];
            this.overwrite = _data["overwrite"];
        }
    }

    static fromJS(data: any): CopyNodeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new CopyNodeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["sourcePath"] = this.sourcePath ? this.sourcePath.toJSON() : <any>undefined;
        data["destinationPath"] = this.destinationPath ? this.destinationPath.toJSON() : <any>undefined;
        data["move"] = this.move;
        data["overwrite"] = this.overwrite;
        return data;
    }
}

export interface ICopyNodeCommand {
    sourcePath: NodePathRequestDto;
    destinationPath: NodePathRequestDto;
    move: boolean;
    overwrite: boolean;
}

export class DeleteNodeCommand implements IDeleteNodeCommand {
    nodePath!: NodePathRequestDto;

    constructor(data?: IDeleteNodeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.nodePath = new NodePathRequestDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nodePath = _data["nodePath"] ? NodePathRequestDto.fromJS(_data["nodePath"]) : new NodePathRequestDto();
        }
    }

    static fromJS(data: any): DeleteNodeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new DeleteNodeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nodePath"] = this.nodePath ? this.nodePath.toJSON() : <any>undefined;
        return data;
    }
}

export interface IDeleteNodeCommand {
    nodePath: NodePathRequestDto;
}

export class QueueSnapshotDto implements IQueueSnapshotDto {
    currentQueuePosition?: string | undefined;
    previousQueuePosition?: string | undefined;
    nextQueuePosition?: string | undefined;
    items!: QueueSnapshotItemDto[];

    constructor(data?: IQueueSnapshotDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.items = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentQueuePosition = _data["currentQueuePosition"];
            this.previousQueuePosition = _data["previousQueuePosition"];
            this.nextQueuePosition = _data["nextQueuePosition"];
            if (Array.isArray(_data["items"])) {
                this.items = [] as any;
                for (let item of _data["items"])
                    this.items!.push(QueueSnapshotItemDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): QueueSnapshotDto {
        data = typeof data === 'object' ? data : {};
        let result = new QueueSnapshotDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentQueuePosition"] = this.currentQueuePosition;
        data["previousQueuePosition"] = this.previousQueuePosition;
        data["nextQueuePosition"] = this.nextQueuePosition;
        if (Array.isArray(this.items)) {
            data["items"] = [];
            for (let item of this.items)
                data["items"].push(item.toJSON());
        }
        return data;
    }
}

export interface IQueueSnapshotDto {
    currentQueuePosition?: string | undefined;
    previousQueuePosition?: string | undefined;
    nextQueuePosition?: string | undefined;
    items: QueueSnapshotItemDto[];
}

export class QueueSnapshotItemDto implements IQueueSnapshotItemDto {
    id!: string;
    type!: QueueSnapshotItemType;
    file!: FileExplorerFileNodeResponse;

    constructor(data?: IQueueSnapshotItemDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.file = new FileExplorerFileNodeResponse();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.type = _data["type"];
            this.file = _data["file"] ? FileExplorerFileNodeResponse.fromJS(_data["file"]) : new FileExplorerFileNodeResponse();
        }
    }

    static fromJS(data: any): QueueSnapshotItemDto {
        data = typeof data === 'object' ? data : {};
        let result = new QueueSnapshotItemDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["type"] = this.type;
        data["file"] = this.file ? this.file.toJSON() : <any>undefined;
        return data;
    }
}

export interface IQueueSnapshotItemDto {
    id: string;
    type: QueueSnapshotItemType;
    file: FileExplorerFileNodeResponse;
}

export enum QueueSnapshotItemType {
    Folder = "Folder",
    User = "User",
}

export class AddToQueueCommand implements IAddToQueueCommand {
    nodePath!: NodePathRequestDto;

    constructor(data?: IAddToQueueCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.nodePath = new NodePathRequestDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nodePath = _data["nodePath"] ? NodePathRequestDto.fromJS(_data["nodePath"]) : new NodePathRequestDto();
        }
    }

    static fromJS(data: any): AddToQueueCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddToQueueCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nodePath"] = this.nodePath ? this.nodePath.toJSON() : <any>undefined;
        return data;
    }
}

export interface IAddToQueueCommand {
    nodePath: NodePathRequestDto;
}

export class RemoveFromQueueCommand implements IRemoveFromQueueCommand {
    queueItems!: string[];

    constructor(data?: IRemoveFromQueueCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.queueItems = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["queueItems"])) {
                this.queueItems = [] as any;
                for (let item of _data["queueItems"])
                    this.queueItems!.push(item);
            }
        }
    }

    static fromJS(data: any): RemoveFromQueueCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RemoveFromQueueCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.queueItems)) {
            data["queueItems"] = [];
            for (let item of this.queueItems)
                data["queueItems"].push(item);
        }
        return data;
    }
}

export interface IRemoveFromQueueCommand {
    queueItems: string[];
}

export class CurrentSessionUpdatedDto implements ICurrentSessionUpdatedDto {
    session?: PlaybackSessionDto | undefined;
    queue!: QueueSnapshotDto;

    constructor(data?: ICurrentSessionUpdatedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.queue = new QueueSnapshotDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.session = _data["session"] ? PlaybackSessionDto.fromJS(_data["session"]) : <any>undefined;
            this.queue = _data["queue"] ? QueueSnapshotDto.fromJS(_data["queue"]) : new QueueSnapshotDto();
        }
    }

    static fromJS(data: any): CurrentSessionUpdatedDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentSessionUpdatedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["session"] = this.session ? this.session.toJSON() : <any>undefined;
        data["queue"] = this.queue ? this.queue.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICurrentSessionUpdatedDto {
    session?: PlaybackSessionDto | undefined;
    queue: QueueSnapshotDto;
}

export class PlaybackSessionDto implements IPlaybackSessionDto {
    id!: string;
    fileDirectory!: string;
    file!: FileExplorerFileNodeResponse;
    streamKey!: StreamKeyDto;
    lastPlayed!: Date;
    playing!: boolean;
    currentTime!: number;
    deviceId?: string | undefined;
    autoPlay!: boolean;
    tracklist!: ImportTracklistDto;

    constructor(data?: IPlaybackSessionDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.file = new FileExplorerFileNodeResponse();
            this.streamKey = new StreamKeyDto();
            this.tracklist = new ImportTracklistDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.id = _data["id"];
            this.fileDirectory = _data["fileDirectory"];
            this.file = _data["file"] ? FileExplorerFileNodeResponse.fromJS(_data["file"]) : new FileExplorerFileNodeResponse();
            this.streamKey = _data["streamKey"] ? StreamKeyDto.fromJS(_data["streamKey"]) : new StreamKeyDto();
            this.lastPlayed = _data["lastPlayed"] ? new Date(_data["lastPlayed"].toString()) : <any>undefined;
            this.playing = _data["playing"];
            this.currentTime = _data["currentTime"];
            this.deviceId = _data["deviceId"];
            this.autoPlay = _data["autoPlay"];
            this.tracklist = _data["tracklist"] ? ImportTracklistDto.fromJS(_data["tracklist"]) : new ImportTracklistDto();
        }
    }

    static fromJS(data: any): PlaybackSessionDto {
        data = typeof data === 'object' ? data : {};
        let result = new PlaybackSessionDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["id"] = this.id;
        data["fileDirectory"] = this.fileDirectory;
        data["file"] = this.file ? this.file.toJSON() : <any>undefined;
        data["streamKey"] = this.streamKey ? this.streamKey.toJSON() : <any>undefined;
        data["lastPlayed"] = this.lastPlayed ? this.lastPlayed.toISOString() : <any>undefined;
        data["playing"] = this.playing;
        data["currentTime"] = this.currentTime;
        data["deviceId"] = this.deviceId;
        data["autoPlay"] = this.autoPlay;
        data["tracklist"] = this.tracklist ? this.tracklist.toJSON() : <any>undefined;
        return data;
    }
}

export interface IPlaybackSessionDto {
    id: string;
    fileDirectory: string;
    file: FileExplorerFileNodeResponse;
    streamKey: StreamKeyDto;
    lastPlayed: Date;
    playing: boolean;
    currentTime: number;
    deviceId?: string | undefined;
    autoPlay: boolean;
    tracklist: ImportTracklistDto;
}

export class StreamKeyDto implements IStreamKeyDto {
    key!: string;
    expires!: number;

    constructor(data?: IStreamKeyDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.key = _data["key"];
            this.expires = _data["expires"];
        }
    }

    static fromJS(data: any): StreamKeyDto {
        data = typeof data === 'object' ? data : {};
        let result = new StreamKeyDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["key"] = this.key;
        data["expires"] = this.expires;
        return data;
    }
}

export interface IStreamKeyDto {
    key: string;
    expires: number;
}

export class ImportTracklistDto implements IImportTracklistDto {
    cues!: ImportCueDto[];

    constructor(data?: IImportTracklistDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.cues = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["cues"])) {
                this.cues = [] as any;
                for (let item of _data["cues"])
                    this.cues!.push(ImportCueDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ImportTracklistDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportTracklistDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.cues)) {
            data["cues"] = [];
            for (let item of this.cues)
                data["cues"].push(item.toJSON());
        }
        return data;
    }
}

export interface IImportTracklistDto {
    cues: ImportCueDto[];
}

export class ImportCueDto implements IImportCueDto {
    cue!: string;
    tracks!: ImportTrackDto[];

    constructor(data?: IImportCueDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.tracks = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.cue = _data["cue"];
            if (Array.isArray(_data["tracks"])) {
                this.tracks = [] as any;
                for (let item of _data["tracks"])
                    this.tracks!.push(ImportTrackDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ImportCueDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportCueDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["cue"] = this.cue;
        if (Array.isArray(this.tracks)) {
            data["tracks"] = [];
            for (let item of this.tracks)
                data["tracks"].push(item.toJSON());
        }
        return data;
    }
}

export interface IImportCueDto {
    cue: string;
    tracks: ImportTrackDto[];
}

export class ImportTrackDto implements IImportTrackDto {
    name!: string;
    artist!: string;
    players!: ImportPlayerDto[];

    constructor(data?: IImportTrackDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.players = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.name = _data["name"];
            this.artist = _data["artist"];
            if (Array.isArray(_data["players"])) {
                this.players = [] as any;
                for (let item of _data["players"])
                    this.players!.push(ImportPlayerDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): ImportTrackDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportTrackDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["name"] = this.name;
        data["artist"] = this.artist;
        if (Array.isArray(this.players)) {
            data["players"] = [];
            for (let item of this.players)
                data["players"].push(item.toJSON());
        }
        return data;
    }
}

export interface IImportTrackDto {
    name: string;
    artist: string;
    players: ImportPlayerDto[];
}

export class ImportPlayerDto implements IImportPlayerDto {
    type!: TracklistPlayerType;
    urls!: string[];

    constructor(data?: IImportPlayerDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.urls = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.type = _data["type"];
            if (Array.isArray(_data["urls"])) {
                this.urls = [] as any;
                for (let item of _data["urls"])
                    this.urls!.push(item);
            }
        }
    }

    static fromJS(data: any): ImportPlayerDto {
        data = typeof data === 'object' ? data : {};
        let result = new ImportPlayerDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["type"] = this.type;
        if (Array.isArray(this.urls)) {
            data["urls"] = [];
            for (let item of this.urls)
                data["urls"].push(item);
        }
        return data;
    }
}

export interface IImportPlayerDto {
    type: TracklistPlayerType;
    urls: string[];
}

export enum TracklistPlayerType {
    Unknown = "Unknown",
    Beatport = "Beatport",
    Apple = "Apple",
    Deezer = "Deezer",
    Traxsource = "Traxsource",
    Bandcamp = "Bandcamp",
    Volumo = "Volumo",
    Soundcloud = "Soundcloud",
    Youtube = "Youtube",
    Mixcloud = "Mixcloud",
    Spotify = "Spotify",
    Hearthis = "Hearthis",
    Affiliate = "Affiliate",
}

export class SetQueuePositionCommand implements ISetQueuePositionCommand {
    queueItemId!: string;

    constructor(data?: ISetQueuePositionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.queueItemId = _data["queueItemId"];
        }
    }

    static fromJS(data: any): SetQueuePositionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SetQueuePositionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["queueItemId"] = this.queueItemId;
        return data;
    }
}

export interface ISetQueuePositionCommand {
    queueItemId: string;
}

export class SyncPlaybackSessionResponse implements ISyncPlaybackSessionResponse {
    useClientState!: boolean;
    session?: PlaybackSessionDto | undefined;

    constructor(data?: ISyncPlaybackSessionResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.useClientState = _data["useClientState"];
            this.session = _data["session"] ? PlaybackSessionDto.fromJS(_data["session"]) : <any>undefined;
        }
    }

    static fromJS(data: any): SyncPlaybackSessionResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SyncPlaybackSessionResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["useClientState"] = this.useClientState;
        data["session"] = this.session ? this.session.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISyncPlaybackSessionResponse {
    useClientState: boolean;
    session?: PlaybackSessionDto | undefined;
}

export class SyncPlaybackSessionCommand implements ISyncPlaybackSessionCommand {
    playbackSessionId?: string | undefined;
    playing!: boolean;
    currentTime!: number;

    constructor(data?: ISyncPlaybackSessionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.playbackSessionId = _data["playbackSessionId"];
            this.playing = _data["playing"];
            this.currentTime = _data["currentTime"];
        }
    }

    static fromJS(data: any): SyncPlaybackSessionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SyncPlaybackSessionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["playbackSessionId"] = this.playbackSessionId;
        data["playing"] = this.playing;
        data["currentTime"] = this.currentTime;
        return data;
    }
}

export interface ISyncPlaybackSessionCommand {
    playbackSessionId?: string | undefined;
    playing: boolean;
    currentTime: number;
}

export class SetCurrentSessionCommand implements ISetCurrentSessionCommand {
    nodePath!: NodePathRequestDto;

    constructor(data?: ISetCurrentSessionCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.nodePath = new NodePathRequestDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nodePath = _data["nodePath"] ? NodePathRequestDto.fromJS(_data["nodePath"]) : new NodePathRequestDto();
        }
    }

    static fromJS(data: any): SetCurrentSessionCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SetCurrentSessionCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nodePath"] = this.nodePath ? this.nodePath.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISetCurrentSessionCommand {
    nodePath: NodePathRequestDto;
}

export class GetUsersSessionsResponse implements IGetUsersSessionsResponse {
    sessions!: PlaybackSessionDto[];

    constructor(data?: IGetUsersSessionsResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.sessions = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["sessions"])) {
                this.sessions = [] as any;
                for (let item of _data["sessions"])
                    this.sessions!.push(PlaybackSessionDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetUsersSessionsResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetUsersSessionsResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.sessions)) {
            data["sessions"] = [];
            for (let item of this.sessions)
                data["sessions"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetUsersSessionsResponse {
    sessions: PlaybackSessionDto[];
}

export class PlaybackStateDto implements IPlaybackStateDto {
    deviceId?: string | undefined;
    playing!: boolean;
    currentTime!: number;
    updateType!: AudioPlayerStateUpdateType;

    constructor(data?: IPlaybackStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.playing = _data["playing"];
            this.currentTime = _data["currentTime"];
            this.updateType = _data["updateType"];
        }
    }

    static fromJS(data: any): PlaybackStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new PlaybackStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["playing"] = this.playing;
        data["currentTime"] = this.currentTime;
        data["updateType"] = this.updateType;
        return data;
    }
}

export interface IPlaybackStateDto {
    deviceId?: string | undefined;
    playing: boolean;
    currentTime: number;
    updateType: AudioPlayerStateUpdateType;
}

export class PlaybackGrantedDto extends PlaybackStateDto implements IPlaybackGrantedDto {
    useDeviceCurrentTime!: boolean;

    constructor(data?: IPlaybackGrantedDto) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.useDeviceCurrentTime = _data["useDeviceCurrentTime"];
        }
    }

    static override fromJS(data: any): PlaybackGrantedDto {
        data = typeof data === 'object' ? data : {};
        let result = new PlaybackGrantedDto();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["useDeviceCurrentTime"] = this.useDeviceCurrentTime;
        super.toJSON(data);
        return data;
    }
}

export interface IPlaybackGrantedDto extends IPlaybackStateDto {
    useDeviceCurrentTime: boolean;
}

export enum AudioPlayerStateUpdateType {
    CurrentTime = "CurrentTime",
    Seek = "Seek",
    PlaybackGranted = "PlaybackGranted",
    Playing = "Playing",
}

export class RequestPlaybackCommand implements IRequestPlaybackCommand {
    deviceId?: string | undefined;

    constructor(data?: IRequestPlaybackCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
        }
    }

    static fromJS(data: any): RequestPlaybackCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RequestPlaybackCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        return data;
    }
}

export interface IRequestPlaybackCommand {
    deviceId?: string | undefined;
}

export class SetPlayingCommand implements ISetPlayingCommand {
    playing!: boolean;
    currentTime!: number;

    constructor(data?: ISetPlayingCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.playing = _data["playing"];
            this.currentTime = _data["currentTime"];
        }
    }

    static fromJS(data: any): SetPlayingCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SetPlayingCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["playing"] = this.playing;
        data["currentTime"] = this.currentTime;
        return data;
    }
}

export interface ISetPlayingCommand {
    playing: boolean;
    currentTime: number;
}

export class SeekRequest implements ISeekRequest {
    time!: number;

    constructor(data?: ISeekRequest) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.time = _data["time"];
        }
    }

    static fromJS(data: any): SeekRequest {
        data = typeof data === 'object' ? data : {};
        let result = new SeekRequest();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["time"] = this.time;
        return data;
    }
}

export interface ISeekRequest {
    time: number;
}

export class SaveTracklistResponse implements ISaveTracklistResponse {
    tracklist!: ImportTracklistDto;

    constructor(data?: ISaveTracklistResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.tracklist = new ImportTracklistDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tracklist = _data["tracklist"] ? ImportTracklistDto.fromJS(_data["tracklist"]) : new ImportTracklistDto();
        }
    }

    static fromJS(data: any): SaveTracklistResponse {
        data = typeof data === 'object' ? data : {};
        let result = new SaveTracklistResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tracklist"] = this.tracklist ? this.tracklist.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISaveTracklistResponse {
    tracklist: ImportTracklistDto;
}

export class SaveTracklistCommand implements ISaveTracklistCommand {
    tracklist!: ImportTracklistDto;

    constructor(data?: ISaveTracklistCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.tracklist = new ImportTracklistDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tracklist = _data["tracklist"] ? ImportTracklistDto.fromJS(_data["tracklist"]) : new ImportTracklistDto();
        }
    }

    static fromJS(data: any): SaveTracklistCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SaveTracklistCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tracklist"] = this.tracklist ? this.tracklist.toJSON() : <any>undefined;
        return data;
    }
}

export interface ISaveTracklistCommand {
    tracklist: ImportTracklistDto;
}

export class ImportTracklistResponse implements IImportTracklistResponse {
    tracklist!: ImportTracklistDto;

    constructor(data?: IImportTracklistResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.tracklist = new ImportTracklistDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.tracklist = _data["tracklist"] ? ImportTracklistDto.fromJS(_data["tracklist"]) : new ImportTracklistDto();
        }
    }

    static fromJS(data: any): ImportTracklistResponse {
        data = typeof data === 'object' ? data : {};
        let result = new ImportTracklistResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["tracklist"] = this.tracklist ? this.tracklist.toJSON() : <any>undefined;
        return data;
    }
}

export interface IImportTracklistResponse {
    tracklist: ImportTracklistDto;
}

export class RequestTranscodeCommand implements IRequestTranscodeCommand {
    nodePath!: NodePathRequestDto;

    constructor(data?: IRequestTranscodeCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.nodePath = new NodePathRequestDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.nodePath = _data["nodePath"] ? NodePathRequestDto.fromJS(_data["nodePath"]) : new NodePathRequestDto();
        }
    }

    static fromJS(data: any): RequestTranscodeCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RequestTranscodeCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["nodePath"] = this.nodePath ? this.nodePath.toJSON() : <any>undefined;
        return data;
    }
}

export interface IRequestTranscodeCommand {
    nodePath: NodePathRequestDto;
}

export class GetAllUsersResponse implements IGetAllUsersResponse {
    users!: UserDto[];

    constructor(data?: IGetAllUsersResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.users = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["users"])) {
                this.users = [] as any;
                for (let item of _data["users"])
                    this.users!.push(UserDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): GetAllUsersResponse {
        data = typeof data === 'object' ? data : {};
        let result = new GetAllUsersResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.users)) {
            data["users"] = [];
            for (let item of this.users)
                data["users"].push(item.toJSON());
        }
        return data;
    }
}

export interface IGetAllUsersResponse {
    users: UserDto[];
}

export class UserDto implements IUserDto {
    userId!: string;
    username!: string;
    roles!: Role[];

    constructor(data?: IUserDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.roles = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
            this.username = _data["username"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): UserDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        data["username"] = this.username;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface IUserDto {
    userId: string;
    username: string;
    roles: Role[];
}

export enum Role {
    Owner = "Owner",
    Administrator = "Administrator",
}

export class AddUserCommandResponse implements IAddUserCommandResponse {
    temporaryPassword!: string;

    constructor(data?: IAddUserCommandResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.temporaryPassword = _data["temporaryPassword"];
        }
    }

    static fromJS(data: any): AddUserCommandResponse {
        data = typeof data === 'object' ? data : {};
        let result = new AddUserCommandResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["temporaryPassword"] = this.temporaryPassword;
        return data;
    }
}

export interface IAddUserCommandResponse {
    temporaryPassword: string;
}

export class AddUserCommand implements IAddUserCommand {
    username!: string;
    roles!: Role[];

    constructor(data?: IAddUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.roles = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.username = _data["username"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): AddUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new AddUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface IAddUserCommand {
    username: string;
    roles: Role[];
}

export class UpdateUserCommand implements IUpdateUserCommand {
    roles?: Role[] | undefined;

    constructor(data?: IUpdateUserCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): UpdateUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new UpdateUserCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface IUpdateUserCommand {
    roles?: Role[] | undefined;
}

export class LoginCommandResponse implements ILoginCommandResponse {
    passwordResetRequired!: boolean;
    accessToken!: string;
    refreshToken!: string;
    deviceId!: string;
    roles!: string[];

    constructor(data?: ILoginCommandResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.roles = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.passwordResetRequired = _data["passwordResetRequired"];
            this.accessToken = _data["accessToken"];
            this.refreshToken = _data["refreshToken"];
            this.deviceId = _data["deviceId"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
        }
    }

    static fromJS(data: any): LoginCommandResponse {
        data = typeof data === 'object' ? data : {};
        let result = new LoginCommandResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["passwordResetRequired"] = this.passwordResetRequired;
        data["accessToken"] = this.accessToken;
        data["refreshToken"] = this.refreshToken;
        data["deviceId"] = this.deviceId;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        return data;
    }
}

export interface ILoginCommandResponse {
    passwordResetRequired: boolean;
    accessToken: string;
    refreshToken: string;
    deviceId: string;
    roles: string[];
}

export class TokenCommand implements ITokenCommand {

    constructor(data?: ITokenCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
    }

    static fromJS(data: any): TokenCommand {
        data = typeof data === 'object' ? data : {};
        let result = new TokenCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        return data;
    }
}

export interface ITokenCommand {
}

export class LoginUserCommand extends TokenCommand implements ILoginUserCommand {
    username!: string;
    password!: string;
    deviceId?: string | undefined;

    constructor(data?: ILoginUserCommand) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.username = _data["username"];
            this.password = _data["password"];
            this.deviceId = _data["deviceId"];
        }
    }

    static override fromJS(data: any): LoginUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new LoginUserCommand();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["username"] = this.username;
        data["password"] = this.password;
        data["deviceId"] = this.deviceId;
        super.toJSON(data);
        return data;
    }
}

export interface ILoginUserCommand extends ITokenCommand {
    username: string;
    password: string;
    deviceId?: string | undefined;
}

export class ResetPasswordCommand implements IResetPasswordCommand {
    currentPassword!: string;
    newPassword!: string;
    newPasswordConfirmation!: string;

    constructor(data?: IResetPasswordCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPassword = _data["currentPassword"];
            this.newPassword = _data["newPassword"];
            this.newPasswordConfirmation = _data["newPasswordConfirmation"];
        }
    }

    static fromJS(data: any): ResetPasswordCommand {
        data = typeof data === 'object' ? data : {};
        let result = new ResetPasswordCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPassword"] = this.currentPassword;
        data["newPassword"] = this.newPassword;
        data["newPasswordConfirmation"] = this.newPasswordConfirmation;
        return data;
    }
}

export interface IResetPasswordCommand {
    currentPassword: string;
    newPassword: string;
    newPasswordConfirmation: string;
}

export class RefreshUserResponse implements IRefreshUserResponse {
    accessToken!: string;
    refreshToken!: string;
    deviceId!: string;
    roles!: string[];
    passwordResetRequired!: boolean;

    constructor(data?: IRefreshUserResponse) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.roles = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.refreshToken = _data["refreshToken"];
            this.deviceId = _data["deviceId"];
            if (Array.isArray(_data["roles"])) {
                this.roles = [] as any;
                for (let item of _data["roles"])
                    this.roles!.push(item);
            }
            this.passwordResetRequired = _data["passwordResetRequired"];
        }
    }

    static fromJS(data: any): RefreshUserResponse {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshUserResponse();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["refreshToken"] = this.refreshToken;
        data["deviceId"] = this.deviceId;
        if (Array.isArray(this.roles)) {
            data["roles"] = [];
            for (let item of this.roles)
                data["roles"].push(item);
        }
        data["passwordResetRequired"] = this.passwordResetRequired;
        return data;
    }
}

export interface IRefreshUserResponse {
    accessToken: string;
    refreshToken: string;
    deviceId: string;
    roles: string[];
    passwordResetRequired: boolean;
}

export class RefreshUserCommand extends TokenCommand implements IRefreshUserCommand {
    accessToken!: string;
    refreshToken!: string;
    deviceId!: string;

    constructor(data?: IRefreshUserCommand) {
        super(data);
    }

    override init(_data?: any) {
        super.init(_data);
        if (_data) {
            this.accessToken = _data["accessToken"];
            this.refreshToken = _data["refreshToken"];
            this.deviceId = _data["deviceId"];
        }
    }

    static override fromJS(data: any): RefreshUserCommand {
        data = typeof data === 'object' ? data : {};
        let result = new RefreshUserCommand();
        result.init(data);
        return result;
    }

    override toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["accessToken"] = this.accessToken;
        data["refreshToken"] = this.refreshToken;
        data["deviceId"] = this.deviceId;
        super.toJSON(data);
        return data;
    }
}

export interface IRefreshUserCommand extends ITokenCommand {
    accessToken: string;
    refreshToken: string;
    deviceId: string;
}

export class CurrentSessionUpdatedEventDto implements ICurrentSessionUpdatedEventDto {
    currentPlaybackSession?: PlaybackSessionDto | undefined;

    constructor(data?: ICurrentSessionUpdatedEventDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentPlaybackSession = _data["currentPlaybackSession"] ? PlaybackSessionDto.fromJS(_data["currentPlaybackSession"]) : <any>undefined;
        }
    }

    static fromJS(data: any): CurrentSessionUpdatedEventDto {
        data = typeof data === 'object' ? data : {};
        let result = new CurrentSessionUpdatedEventDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentPlaybackSession"] = this.currentPlaybackSession ? this.currentPlaybackSession.toJSON() : <any>undefined;
        return data;
    }
}

export interface ICurrentSessionUpdatedEventDto {
    currentPlaybackSession?: PlaybackSessionDto | undefined;
}

export class DeviceStateDto implements IDeviceStateDto {
    deviceId!: string;
    lastInteractedWith!: string;
    interactedWith!: boolean;
    online!: boolean;
    capabilities!: { [key: string]: boolean; };

    constructor(data?: IDeviceStateDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.capabilities = {};
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
            this.lastInteractedWith = _data["lastInteractedWith"];
            this.interactedWith = _data["interactedWith"];
            this.online = _data["online"];
            if (_data["capabilities"]) {
                this.capabilities = {} as any;
                for (let key in _data["capabilities"]) {
                    if (_data["capabilities"].hasOwnProperty(key))
                        (<any>this.capabilities)![key] = _data["capabilities"][key];
                }
            }
        }
    }

    static fromJS(data: any): DeviceStateDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceStateDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        data["lastInteractedWith"] = this.lastInteractedWith;
        data["interactedWith"] = this.interactedWith;
        data["online"] = this.online;
        if (this.capabilities) {
            data["capabilities"] = {};
            for (let key in this.capabilities) {
                if (this.capabilities.hasOwnProperty(key))
                    (<any>data["capabilities"])[key] = (<any>this.capabilities)[key];
            }
        }
        return data;
    }
}

export interface IDeviceStateDto {
    deviceId: string;
    lastInteractedWith: string;
    interactedWith: boolean;
    online: boolean;
    capabilities: { [key: string]: boolean; };
}

export class DeviceDeletedDto implements IDeviceDeletedDto {
    deviceId!: string;

    constructor(data?: IDeviceDeletedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.deviceId = _data["deviceId"];
        }
    }

    static fromJS(data: any): DeviceDeletedDto {
        data = typeof data === 'object' ? data : {};
        let result = new DeviceDeletedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["deviceId"] = this.deviceId;
        return data;
    }
}

export interface IDeviceDeletedDto {
    deviceId: string;
}

export class UserDeletedDto implements IUserDeletedDto {
    userId!: string;

    constructor(data?: IUserDeletedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.userId = _data["userId"];
        }
    }

    static fromJS(data: any): UserDeletedDto {
        data = typeof data === 'object' ? data : {};
        let result = new UserDeletedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["userId"] = this.userId;
        return data;
    }
}

export interface IUserDeletedDto {
    userId: string;
}

export class FileExplorerNodeUpdatedDto implements IFileExplorerNodeUpdatedDto {
    node!: FileExplorerNodeResponse;
    index!: number;
    oldPath?: NodePathDto | undefined;

    constructor(data?: IFileExplorerNodeUpdatedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.node = new FileExplorerNodeResponse();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.node = _data["node"] ? FileExplorerNodeResponse.fromJS(_data["node"]) : new FileExplorerNodeResponse();
            this.index = _data["index"];
            this.oldPath = _data["oldPath"] ? NodePathDto.fromJS(_data["oldPath"]) : <any>undefined;
        }
    }

    static fromJS(data: any): FileExplorerNodeUpdatedDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileExplorerNodeUpdatedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["node"] = this.node ? this.node.toJSON() : <any>undefined;
        data["index"] = this.index;
        data["oldPath"] = this.oldPath ? this.oldPath.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFileExplorerNodeUpdatedDto {
    node: FileExplorerNodeResponse;
    index: number;
    oldPath?: NodePathDto | undefined;
}

export class FileExplorerNodeDeletedDto implements IFileExplorerNodeDeletedDto {
    parent!: FileExplorerFolderNodeResponse;
    nodePath!: NodePathDto;

    constructor(data?: IFileExplorerNodeDeletedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.parent = new FileExplorerFolderNodeResponse();
            this.nodePath = new NodePathDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.parent = _data["parent"] ? FileExplorerFolderNodeResponse.fromJS(_data["parent"]) : new FileExplorerFolderNodeResponse();
            this.nodePath = _data["nodePath"] ? NodePathDto.fromJS(_data["nodePath"]) : new NodePathDto();
        }
    }

    static fromJS(data: any): FileExplorerNodeDeletedDto {
        data = typeof data === 'object' ? data : {};
        let result = new FileExplorerNodeDeletedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["parent"] = this.parent ? this.parent.toJSON() : <any>undefined;
        data["nodePath"] = this.nodePath ? this.nodePath.toJSON() : <any>undefined;
        return data;
    }
}

export interface IFileExplorerNodeDeletedDto {
    parent: FileExplorerFolderNodeResponse;
    nodePath: NodePathDto;
}

export class MediaInfoUpdatedDto implements IMediaInfoUpdatedDto {
    mediaInfo!: MediaInfoDto[];

    constructor(data?: IMediaInfoUpdatedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.mediaInfo = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["mediaInfo"])) {
                this.mediaInfo = [] as any;
                for (let item of _data["mediaInfo"])
                    this.mediaInfo!.push(MediaInfoDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MediaInfoUpdatedDto {
        data = typeof data === 'object' ? data : {};
        let result = new MediaInfoUpdatedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.mediaInfo)) {
            data["mediaInfo"] = [];
            for (let item of this.mediaInfo)
                data["mediaInfo"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMediaInfoUpdatedDto {
    mediaInfo: MediaInfoDto[];
}

export class MediaInfoRemovedDto implements IMediaInfoRemovedDto {
    nodePaths!: NodePathDto[];

    constructor(data?: IMediaInfoRemovedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.nodePaths = [];
        }
    }

    init(_data?: any) {
        if (_data) {
            if (Array.isArray(_data["nodePaths"])) {
                this.nodePaths = [] as any;
                for (let item of _data["nodePaths"])
                    this.nodePaths!.push(NodePathDto.fromJS(item));
            }
        }
    }

    static fromJS(data: any): MediaInfoRemovedDto {
        data = typeof data === 'object' ? data : {};
        let result = new MediaInfoRemovedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        if (Array.isArray(this.nodePaths)) {
            data["nodePaths"] = [];
            for (let item of this.nodePaths)
                data["nodePaths"].push(item.toJSON());
        }
        return data;
    }
}

export interface IMediaInfoRemovedDto {
    nodePaths: NodePathDto[];
}

export class TracklistUpdatedDto implements ITracklistUpdatedDto {
    path!: NodePathDto;
    tracklist!: ImportTracklistDto;

    constructor(data?: ITracklistUpdatedDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
        if (!data) {
            this.path = new NodePathDto();
            this.tracklist = new ImportTracklistDto();
        }
    }

    init(_data?: any) {
        if (_data) {
            this.path = _data["path"] ? NodePathDto.fromJS(_data["path"]) : new NodePathDto();
            this.tracklist = _data["tracklist"] ? ImportTracklistDto.fromJS(_data["tracklist"]) : new ImportTracklistDto();
        }
    }

    static fromJS(data: any): TracklistUpdatedDto {
        data = typeof data === 'object' ? data : {};
        let result = new TracklistUpdatedDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["path"] = this.path ? this.path.toJSON() : <any>undefined;
        data["tracklist"] = this.tracklist ? this.tracklist.toJSON() : <any>undefined;
        return data;
    }
}

export interface ITracklistUpdatedDto {
    path: NodePathDto;
    tracklist: ImportTracklistDto;
}

export class SignalRUpdatePlaybackStateCommand implements ISignalRUpdatePlaybackStateCommand {
    currentTime!: number;

    constructor(data?: ISignalRUpdatePlaybackStateCommand) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.currentTime = _data["currentTime"];
        }
    }

    static fromJS(data: any): SignalRUpdatePlaybackStateCommand {
        data = typeof data === 'object' ? data : {};
        let result = new SignalRUpdatePlaybackStateCommand();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["currentTime"] = this.currentTime;
        return data;
    }
}

export interface ISignalRUpdatePlaybackStateCommand {
    currentTime: number;
}

export class DebugMessageDto implements IDebugMessageDto {
    level!: LogLevel;
    message!: string;

    constructor(data?: IDebugMessageDto) {
        if (data) {
            for (var property in data) {
                if (data.hasOwnProperty(property))
                    (<any>this)[property] = (<any>data)[property];
            }
        }
    }

    init(_data?: any) {
        if (_data) {
            this.level = _data["level"];
            this.message = _data["message"];
        }
    }

    static fromJS(data: any): DebugMessageDto {
        data = typeof data === 'object' ? data : {};
        let result = new DebugMessageDto();
        result.init(data);
        return result;
    }

    toJSON(data?: any) {
        data = typeof data === 'object' ? data : {};
        data["level"] = this.level;
        data["message"] = this.message;
        return data;
    }
}

export interface IDebugMessageDto {
    level: LogLevel;
    message: string;
}

export enum LogLevel {
    Trace = "Trace",
    Debug = "Debug",
    Information = "Information",
    Warning = "Warning",
    Error = "Error",
    Critical = "Critical",
    None = "None",
}

export interface FileParameter {
    data: any;
    fileName: string;
}

export interface FileResponse {
    data: Blob;
    status: number;
    fileName?: string;
    headers?: { [name: string]: any };
}

export class ApiException extends Error {
    override message: string;
    status: number;
    response: string;
    headers: { [key: string]: any; };
    result: any;

    constructor(message: string, status: number, response: string, headers: { [key: string]: any; }, result: any) {
        super();

        this.message = message;
        this.status = status;
        this.response = response;
        this.headers = headers;
        this.result = result;
    }

    protected isApiException = true;

    static isApiException(obj: any): obj is ApiException {
        return obj.isApiException === true;
    }
}

function throwException(message: string, status: number, response: string, headers: { [key: string]: any; }, result?: any): Observable<any> {
    if (result !== null && result !== undefined)
        return _observableThrow(result);
    else
        return _observableThrow(new ApiException(message, status, response, headers, null));
}

function blobToText(blob: any): Observable<string> {
    return new Observable<string>((observer: any) => {
        if (!blob) {
            observer.next("");
            observer.complete();
        } else {
            let reader = new FileReader();
            reader.onload = event => {
                observer.next((event.target as any).result);
                observer.complete();
            };
            reader.readAsText(blob);
        }
    });
}
